"""add role to user model

Revision ID: 15f8013d935f
Revises: 5bcc6a834d58
Create Date: 2025-05-02 15:45:02.012345 # <<< Tu fecha de creación de migración aquí

"""
from alembic import op
import sqlalchemy as sa

# Importar el modelo User para poder usarlo en la migración
# Asegúrate de que la importación es correcta desde tu paquete
from autointelli.models import User # <<< IMPORTACIÓN DEL MODELO

import logging # Importar logging para usarlo en la migración

logger = logging.getLogger(__name__) # Logger para la migración

# revision identifiers, used by Alembic.
revision = '15f8013d935f'
down_revision = '5bcc6a834d58' # <<< ID de la migración anterior (tu migración inicial)
branch_labels = None
depends_on = None


def upgrade():
    logger.info(f"Running upgrade for revision {revision}")
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user', schema=None) as batch_op:
        # AÑADIR LA COLUMNA 'role' TEMPORALMENTE PERMITIENDO NULL
        # Alembic a veces genera esto, pero nos aseguramos que sea nullable=True inicialmente
        logger.info("Adding column 'role' to 'user' table (nullable=True)...")
        batch_op.add_column(sa.Column('role', sa.String(length=50), nullable=True)) # <<< AÑADIR CON nullable=True

    # --- AHORA, ACTUALIZAR LAS FILAS EXISTENTES ---
    logger.info("Updating existing users with default role 'logistica'...")
    # Obtener la conexión de Alembic y crear una sesión ORM
    bind = op.get_bind()
    session = sa.orm.Session(bind=bind)

    try:
        # Ejecutar una consulta de actualización para asignar 'logistica' donde 'role' es NULL
        # Usamos execute con sa.text para SQL crudo, asegurándonos de las comillas para PostgreSQL
        # El nombre de la tabla es 'user' por defecto de SQLAlchemy
         session.execute(
             sa.text("""
             UPDATE "user" SET role = 'logistica' WHERE role IS NULL
             """)
         )
         session.commit() # Confirmar la actualización
         logger.info("Updated existing users with default role 'logistica' successfully.")

    except Exception as e:
         session.rollback()
         logger.error(f"Error updating existing users in migration {revision}: {e}", exc_info=True)
         # Si la actualización falla, probablemente queremos que la migración falle.
         # Podemos re-lanzar la excepción.
         raise # Re-lanzar la excepción para detener la migración

    finally:
         session.close() # Siempre cerrar la sesión


    # --- FINALMENTE, AÑADIR LA RESTRICCIÓN NOT NULL ---
    # Ahora que todas las filas tienen un valor, podemos hacer la columna NOT NULL
    logger.info("Adding NOT NULL constraint to 'role' column...")
    with op.batch_alter_table('user', schema=None) as batch_op:
         # Alterar la columna para que ya no permita NULL
         batch_op.alter_column('role', nullable=False) # <<< Alterar para nullable=False

    # ### end Alembic commands ###
    logger.info(f"Upgrade for revision {revision} completed successfully.")


def downgrade():
    logger.info(f"Running downgrade for revision {revision}")
    # ### commands auto generated by Alembic - please adjust! ###
    # La función downgrade debe UNDO lo que hace upgrade.
    # Lo último que hicimos fue añadir la restricción NOT NULL y actualizar. Lo primero que hicimos fue añadir la columna.
    # El downgrade solo necesita eliminar la columna.
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.drop_column('role') # <<< Eliminar la columna

    # ### end Alembic commands ###
    logger.info(f"Downgrade for revision {revision} completed successfully.")